-- ======================================================================
-- V1__init_app_chema.sql
-- Схема БД для сервиса тестирования интеграций
-- Назначение: справочники, сущности "проверки", их профили и результаты
-- Политика удаления:
--   - h_check_* (профили) удаляются каскадно при удалении проверки
--   - h_check_result сохраняется (FK SET NULL), чтобы не терять историю
-- ======================================================================

-- ---------------------------------------------------------------------
-- Создание отдельной схемы для объектов сервиса тестирования интеграций
-- ---------------------------------------------------------------------
CREATE SCHEMA IF NOT EXISTS ${app_schema};
COMMENT ON SCHEMA ${app_schema} IS 'Схема для объектов сервиса тестирования интеграций';

-- -----------------------------
-- Бизнес-сущность: Проверка
-- -----------------------------
CREATE TABLE IF NOT EXISTS ${app_schema}.h_check
(
    id               BIGINT GENERATED BY DEFAULT AS IDENTITY,
    name             VARCHAR(250) NOT NULL,
    description      VARCHAR(1000),
    is_enabled       BOOLEAN      NOT NULL DEFAULT TRUE,
    run_interval_min INTEGER      NOT NULL,
    next_run_at      TIMESTAMP    NOT NULL DEFAULT NOW(),
    type_code        TEXT         NOT NULL,

    CONSTRAINT pk_h_check PRIMARY KEY (id),
    CONSTRAINT uq_h_check__name UNIQUE (name),
    CONSTRAINT ck_h_check__interval_range CHECK (run_interval_min BETWEEN 1 AND 10080)
);
COMMENT ON TABLE ${app_schema}.h_check IS 'Список проверок (задачи планировщика)';
COMMENT ON COLUMN ${app_schema}.h_check.id IS 'Идентификатор проверки (PK)';
COMMENT ON COLUMN ${app_schema}.h_check.name IS 'Уникальное имя проверки';
COMMENT ON COLUMN ${app_schema}.h_check.description IS 'Описание проверки';
COMMENT ON COLUMN ${app_schema}.h_check.is_enabled IS 'Флаг включения проверки';
COMMENT ON COLUMN ${app_schema}.h_check.run_interval_min IS 'Период запусков в минутах (1..10080)';
COMMENT ON COLUMN ${app_schema}.h_check.next_run_at IS 'Следующее запланированное время запуска';
COMMENT ON COLUMN ${app_schema}.h_check.type_code IS 'Тип проверки';

-- Индекс для планировщика: "просроченные" и ближайшие проверки
CREATE INDEX IF NOT EXISTS ix_h_check__due
    ON ${app_schema}.h_check (next_run_at)
    WHERE is_enabled IS TRUE;
COMMENT ON INDEX ${app_schema}.ix_h_check__due IS 'Ускоряет выборку просроченных/ближайших проверок при is_enabled=TRUE';

-- ----------------------------------
-- Параметры для URL/HTTP-проверок
-- ----------------------------------
CREATE TABLE IF NOT EXISTS ${app_schema}.h_check_http
(
    id               BIGINT GENERATED BY DEFAULT AS IDENTITY,
    check_id         BIGINT  NOT NULL,
    url              TEXT    NOT NULL,
    http_method_code TEXT    NOT NULL,
    timeout_seconds  INTEGER NOT NULL DEFAULT 30,
    headers          TEXT,
    request_body     TEXT,

    CONSTRAINT pk_h_check_http PRIMARY KEY (id),
    CONSTRAINT fk_h_check_http__check_type FOREIGN KEY (check_id) REFERENCES ${app_schema}.h_check (id) ON DELETE CASCADE,
    CONSTRAINT ck_h_check_http__timeout_range CHECK (timeout_seconds BETWEEN 1 AND 600)
);
COMMENT ON TABLE ${app_schema}.h_check_http IS 'Параметры для проверок REST API';
COMMENT ON COLUMN ${app_schema}.h_check_http.check_id IS 'FK на h_check.id (PK этой таблицы)';
COMMENT ON COLUMN ${app_schema}.h_check_http.url IS 'Целевой URL';
COMMENT ON COLUMN ${app_schema}.h_check_http.http_method_code IS 'HTTP-метод';
COMMENT ON COLUMN ${app_schema}.h_check_http.timeout_seconds IS 'Таймаут HTTP-запроса, сек';
COMMENT ON COLUMN ${app_schema}.h_check_http.headers IS 'Заголовки запроса';
COMMENT ON COLUMN ${app_schema}.h_check_http.request_body IS 'Шаблон тела запроса';

CREATE INDEX IF NOT EXISTS ix_h_check_http__check_id
    ON ${app_schema}.h_check_http (check_id);

-- ------------------------------
-- Результаты запусков проверок
-- ------------------------------
CREATE TABLE IF NOT EXISTS ${app_schema}.h_check_result
(
    id               BIGINT GENERATED BY DEFAULT AS IDENTITY,
    check_id         BIGINT,
    cluster_id       TEXT      NOT NULL,
    started_at       TIMESTAMP NOT NULL,
    status_code      TEXT      NOT NULL,
    details          TEXT,
    error_code       VARCHAR(100),
    error_message    TEXT,
    http_status_code INTEGER,

    CONSTRAINT pk_h_check_result PRIMARY KEY (id),
    CONSTRAINT fk_h_check_result__check FOREIGN KEY (check_id) REFERENCES ${app_schema}.h_check (id) ON DELETE SET NULL,
    CONSTRAINT ck_h_check_result__http_status_range CHECK (http_status_code IS NULL OR (http_status_code BETWEEN 100 AND 599))
);
COMMENT ON TABLE ${app_schema}.h_check_result IS 'История запусков проверок';
COMMENT ON COLUMN ${app_schema}.h_check_result.check_id IS 'FK на проверку (может быть NULL для общесистемных событий)';
COMMENT ON COLUMN ${app_schema}.h_check_result.cluster_id IS 'Идентификатор кластера/окружения';
COMMENT ON COLUMN ${app_schema}.h_check_result.started_at IS 'Время начала выполнения';
COMMENT ON COLUMN ${app_schema}.h_check_result.status_code IS 'Статус результата: SUCCESS/FAILURE/TIMEOUT/ERROR';
COMMENT ON COLUMN ${app_schema}.h_check_result.details IS 'Детали выполнения/ответа (JSON-объект)';
COMMENT ON COLUMN ${app_schema}.h_check_result.error_code IS 'Код ошибки/исключения';
COMMENT ON COLUMN ${app_schema}.h_check_result.error_message IS 'Краткое сообщение об ошибке';
COMMENT ON COLUMN ${app_schema}.h_check_result.http_status_code IS 'HTTP-статус (для URL-проверок)';

CREATE INDEX IF NOT EXISTS ix_h_check_result__check_time
    ON ${app_schema}.h_check_result (check_id, started_at DESC);
COMMENT ON INDEX ${app_schema}.ix_h_check_result__check_time IS 'Поиск результатов по проверке и времени';

-- В манифесте пода надо добавить окружение с именем пода:
-- env:
--   - name: POD_NAME
--     valueFrom:
--       fieldRef:
--         fieldPath: metadata.name

create table if not exists batch_singleton (
    job_name  text primary key,
    owner_id  text not null,      -- активный под
    enabled   boolean not null,   -- включен ли запуск вообще
    since     timestamptz not null default now()
);

-- начальная инициализация: все в standby
insert into batch_singleton(job_name, owner_id, enabled)
values ('integrationHealthJob', 'NONE', false)
on conflict (job_name) do nothing;

-- -- Включить job и назначить владельца pod-A:
-- update batch_singleton
-- set owner_id = 'pod-A', enabled = true, since = now()
-- where job_name = 'integrationHealthJob';
--
-- -- Переключить на pod-B:
-- update batch_singleton
-- set owner_id = 'pod-B', since = now()
-- where job_name = 'integrationHealthJob';
--
-- -- Полностью выключить (все в standby):
-- update batch_singleton
-- set enabled = false, since = now()
-- where job_name = 'integrationHealthJob';

-- -- -----------------------------
-- -- Блокировки выполнения
-- -- -----------------------------
-- CREATE TABLE IF NOT EXISTS ${app_schema}.h_check_lock
-- (
--     check_id     BIGINT    NOT NULL,
--     cluster_id   TEXT      NOT NULL,
--     locked_until TIMESTAMP NOT NULL,
--
--     CONSTRAINT pk_h_check_lock PRIMARY KEY (check_id, cluster_id),
--     CONSTRAINT fk_h_check_lock__check FOREIGN KEY (check_id) REFERENCES ${app_schema}.h_check (id) ON DELETE CASCADE
-- );
-- COMMENT ON TABLE ${app_schema}.h_check_lock IS 'Блокировка выполнения проверки внутри кластера (check_id + cluster_id)';
-- COMMENT ON COLUMN ${app_schema}.h_check_lock.locked_until IS 'Момент истечения блокировки; после — блокировка может быть перехвачена';
--
-- CREATE INDEX IF NOT EXISTS ix_h_check_lock__locked_until
--     ON ${app_schema}.h_check_lock (locked_until);
-- COMMENT ON INDEX ${app_schema}.ix_h_check_lock__locked_until IS 'Ускоряет выборку блокировок, истёкших по времени';